{"version":3,"sources":["webpack:///./src/components/textarea/tests/TextArea.spec.tsx"],"names":[],"mappings":"6FAAA,OAAe","file":"assets/871.bundle.js","sourcesContent":["export default \"import {HTMLAttributes, mount, ReactWrapper, shallow} from 'enzyme';\\r\\nimport * as React from 'react';\\r\\nimport {Provider} from 'react-redux';\\r\\nimport {Store} from 'redux';\\r\\nimport {findWhere} from 'underscore';\\r\\n\\r\\nimport {IReactVaporState} from '../../../ReactVapor';\\r\\nimport {clearState} from '../../../utils/ReduxUtils';\\r\\nimport {TestUtils} from '../../../utils/tests/TestUtils';\\r\\nimport {ITextAreaProps, TextArea, TextAreaConnected} from '../TextArea';\\r\\nimport {ITextAreaState} from '../TextAreaReducers';\\r\\n\\r\\ndescribe('TextArea', () => {\\r\\n    describe('<TextArea />', () => {\\r\\n        it('should render without errors', () => {\\r\\n            expect(() => {\\r\\n                shallow(<TextArea id=\\\"textarea-id\\\" />);\\r\\n            }).not.toThrow();\\r\\n        });\\r\\n    });\\r\\n\\r\\n    describe('<TextArea />', () => {\\r\\n        let wrapper: ReactWrapper<ITextAreaProps, any>;\\r\\n        let textArea: ReactWrapper<HTMLAttributes, any>;\\r\\n\\r\\n        beforeEach(() => {\\r\\n            wrapper = mount(<TextArea id=\\\"textarea-id\\\" />, {attachTo: document.getElementById('App')});\\r\\n\\r\\n            textArea = wrapper.find('textarea').first();\\r\\n        });\\r\\n\\r\\n        afterEach(() => {\\r\\n            wrapper.detach();\\r\\n        });\\r\\n\\r\\n        it('should set textarea id when specified', () => {\\r\\n            expect(textArea.prop('id')).toBe('textarea-id');\\r\\n        });\\r\\n\\r\\n        it('should set className when specified', () => {\\r\\n            const className = 'a-class';\\r\\n            expect(textArea.hasClass(className)).toBe(false);\\r\\n\\r\\n            wrapper.setProps({className}).update();\\r\\n            expect(wrapper.find('textarea').hasClass(className)).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should set additionalAttributes when specified', () => {\\r\\n            expect(textArea.prop('placeholder')).toBeUndefined();\\r\\n            wrapper.setProps({additionalAttributes: {placeholder: 'not null'}}).update();\\r\\n            expect(wrapper.find('textarea').prop('placeholder')).toBe('not null');\\r\\n        });\\r\\n\\r\\n        it('should set disabled prop when specified', () => {\\r\\n            expect(textArea.prop('disabled')).toBeUndefined();\\r\\n            wrapper.setProps({disabled: true}).update();\\r\\n            expect(wrapper.find('textarea').prop('disabled')).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should set value prop when specified', () => {\\r\\n            expect(textArea.prop('value')).toBeUndefined();\\r\\n            wrapper.setProps({value: 'non empty'}).update();\\r\\n            expect(wrapper.find('textarea').prop('value')).toBe('non empty');\\r\\n        });\\r\\n\\r\\n        it('should not throw if the onChange prop is not defined onChange', () => {\\r\\n            wrapper.setProps({onChange: undefined}).update();\\r\\n\\r\\n            expect(() => (wrapper.instance() as any).handleOnChange()).not.toThrow();\\r\\n        });\\r\\n\\r\\n        it('should not throw if the onChangeCallback prop is not defined onChange', () => {\\r\\n            wrapper.setProps({onChangeCallback: undefined});\\r\\n\\r\\n            expect(() => (wrapper.instance() as any).handleOnChange()).not.toThrow();\\r\\n        });\\r\\n\\r\\n        it('should call prop onChange on textarea change', () => {\\r\\n            const onChange = jasmine.createSpy('onChange');\\r\\n\\r\\n            wrapper.setProps({onChange}).update();\\r\\n            wrapper.find('textarea').simulate('change');\\r\\n\\r\\n            expect(onChange).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onChangeCallback on textarea change', () => {\\r\\n            const onChangeCallback = jasmine.createSpy('onChangeCallback');\\r\\n\\r\\n            wrapper.setProps({onChangeCallback}).update();\\r\\n            wrapper.find('textarea').simulate('change');\\r\\n\\r\\n            expect(onChangeCallback).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onMount on mount', () => {\\r\\n            const onMount = jasmine.createSpy('onMount');\\r\\n\\r\\n            wrapper\\r\\n                .setProps({onMount})\\r\\n                .unmount()\\r\\n                .mount();\\r\\n\\r\\n            expect(onMount).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onUnmount on Unmount', () => {\\r\\n            const onUnmount = jasmine.createSpy('onUnmount');\\r\\n\\r\\n            wrapper.setProps({onUnmount}).unmount();\\r\\n\\r\\n            expect(onUnmount).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        describe('<TextAreaConnected />', () => {\\r\\n            let store: Store<IReactVaporState>;\\r\\n            let textAreaProps: ITextAreaProps;\\r\\n\\r\\n            const getTextAreaStateFromId = (id: string): ITextAreaState => findWhere(store.getState().textAreas, {id});\\r\\n\\r\\n            const mountComponentWithProps = (props: ITextAreaProps) =>\\r\\n                mount(\\r\\n                    <Provider store={store}>\\r\\n                        <TextAreaConnected {...props} />\\r\\n                    </Provider>,\\r\\n                    {attachTo: document.getElementById('App')}\\r\\n                );\\r\\n\\r\\n            beforeEach(() => {\\r\\n                store = TestUtils.buildStore();\\r\\n                textAreaProps = {id: 'textarea-id'};\\r\\n            });\\r\\n\\r\\n            afterEach(() => {\\r\\n                store.dispatch(clearState());\\r\\n                wrapper.detach();\\r\\n            });\\r\\n\\r\\n            describe('dispatch props', () => {\\r\\n                it('should not throw when calling onMount with basic props', () => {\\r\\n                    expect(() =>\\r\\n                        mountComponentWithProps(textAreaProps)\\r\\n                            .find(TextArea)\\r\\n                            .prop('onMount')()\\r\\n                    ).not.toThrow();\\r\\n                });\\r\\n\\r\\n                it('should not throw when calling onUnmount', () => {\\r\\n                    expect(() =>\\r\\n                        mountComponentWithProps(textAreaProps)\\r\\n                            .find(TextArea)\\r\\n                            .prop('onUnmount')()\\r\\n                    ).not.toThrow();\\r\\n                });\\r\\n\\r\\n                it('should not throw when calling onChange', () => {\\r\\n                    expect(() =>\\r\\n                        mountComponentWithProps(textAreaProps)\\r\\n                            .find(TextArea)\\r\\n                            .prop('onChange')({target: {value: 'some value'}} as any)\\r\\n                    ).not.toThrow();\\r\\n                });\\r\\n            });\\r\\n\\r\\n            describe('onMount', () => {\\r\\n                it('should add a textArea in the store with default values', () => {\\r\\n                    mountComponentWithProps(textAreaProps);\\r\\n\\r\\n                    const connectedTextArea: ITextAreaState = getTextAreaStateFromId(textAreaProps.id);\\r\\n                    expect(connectedTextArea.value).toBe('');\\r\\n                    expect(connectedTextArea.disabled).toBe(false);\\r\\n                });\\r\\n\\r\\n                it('should add a textArea in the store with the valueOnMount if there is one in the props', () => {\\r\\n                    const valueOnMount = 'non empty value';\\r\\n                    mountComponentWithProps({...textAreaProps, valueOnMount});\\r\\n\\r\\n                    const connectedTextArea: ITextAreaState = getTextAreaStateFromId(textAreaProps.id);\\r\\n                    expect(connectedTextArea.value).toBe(valueOnMount);\\r\\n                    expect(connectedTextArea.disabled).toBe(false);\\r\\n                });\\r\\n\\r\\n                it('should add a textArea in the store with the disabledOnMount value if there is one in the props', () => {\\r\\n                    const disabledOnMount = true;\\r\\n                    mountComponentWithProps({...textAreaProps, disabledOnMount});\\r\\n\\r\\n                    const connectedTextArea: ITextAreaState = getTextAreaStateFromId(textAreaProps.id);\\r\\n                    expect(connectedTextArea.value).toBe('');\\r\\n                    expect(connectedTextArea.disabled).toBe(disabledOnMount);\\r\\n                });\\r\\n            });\\r\\n\\r\\n            describe('onUnmount', () => {\\r\\n                it('should remove the textArea from the store', () => {\\r\\n                    const connectedTextArea = mountComponentWithProps(textAreaProps);\\r\\n\\r\\n                    expect(getTextAreaStateFromId(textAreaProps.id)).toBeDefined();\\r\\n\\r\\n                    connectedTextArea.unmount();\\r\\n\\r\\n                    expect(getTextAreaStateFromId(textAreaProps.id)).toBeUndefined();\\r\\n                });\\r\\n            });\\r\\n\\r\\n            describe('onChange', () => {\\r\\n                it('should change the value in the store to the new value', () => {\\r\\n                    const connectedTextArea = mountComponentWithProps(textAreaProps);\\r\\n                    const oldTextAreaState: ITextAreaState = getTextAreaStateFromId(textAreaProps.id);\\r\\n                    expect(oldTextAreaState.value).toBe('');\\r\\n\\r\\n                    (document.querySelector(`#${textAreaProps.id}`) as HTMLTextAreaElement).value = 'new value';\\r\\n                    connectedTextArea.find('textarea').simulate('change', {target: {value: 'new value'}});\\r\\n\\r\\n                    const newTextAreaState: ITextAreaState = getTextAreaStateFromId(textAreaProps.id);\\r\\n                    expect(newTextAreaState.value).toBe('new value');\\r\\n                });\\r\\n            });\\r\\n        });\\r\\n    });\\r\\n});\\r\\n\""],"sourceRoot":""}