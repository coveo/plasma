(window.webpackJsonp=window.webpackJsonp||[]).push([[299],{1395:function(e,t,r){"use strict";r.r(t),t.default="import * as moment from 'moment';\r\nimport * as _ from 'underscore';\r\nimport {IReduxAction} from '../../../utils/ReduxUtils';\r\nimport {\r\n    DateLimits,\r\n    DatePickerActions,\r\n    IAddDatePickerPayload,\r\n    IChangeDatePickerPayload,\r\n    IDatePickerPayload,\r\n    ISelectDatePickerPayload,\r\n} from '../DatePickerActions';\r\nimport {\r\n    datePickerInitialState,\r\n    datePickerReducer,\r\n    datePickersInitialState,\r\n    datePickersReducer,\r\n    IDatePickerState,\r\n} from '../DatePickerReducers';\r\nimport {IRangeLimit} from '../DatesSelection';\r\n\r\ndescribe('Date picker', () => {\r\n    const GENERIC_ACTION: IReduxAction<IDatePickerPayload> = {\r\n        type: 'DO_SOMETHING',\r\n        payload: {\r\n            id: 'some-date-picker',\r\n        },\r\n    };\r\n\r\n    const BASE_DATE_PICKER_STATE: IDatePickerState = {\r\n        id: 'some-date-picker',\r\n        calendarId: 'some-calendar',\r\n        color: 'teal',\r\n        isRange: false,\r\n        lowerLimit: new Date(new Date().setHours(2, 1, 2, 1)),\r\n        upperLimit: new Date(new Date().setHours(3, 2, 1, 2)),\r\n        selected: '',\r\n        appliedLowerLimit: new Date(new Date().setHours(0, 0, 0, 0)),\r\n        appliedUpperLimit: new Date(new Date().setHours(23, 59, 59, 999)),\r\n        inputLowerLimit: new Date(new Date().setHours(0, 0, 0, 0)),\r\n        inputUpperLimit: new Date(new Date().setHours(23, 59, 59, 999)),\r\n        isClearable: false,\r\n        simple: false,\r\n    };\r\n\r\n    describe('datePickersReducer', () => {\r\n        it('should return the default state if the action is not defined and the state is undefined', () => {\r\n            const datePickersState: IDatePickerState[] = datePickersReducer(undefined, GENERIC_ACTION);\r\n\r\n            expect(datePickersState).toBe(datePickersInitialState);\r\n        });\r\n\r\n        it('should return the old state when the action is not defined', () => {\r\n            const oldDatePickers: IDatePickerState[] = [_.extend({}, BASE_DATE_PICKER_STATE)];\r\n            const newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, GENERIC_ACTION);\r\n\r\n            expect(newDatePickers).toBe(oldDatePickers);\r\n        });\r\n\r\n        describe('\"ADD_DATE_PICKER\" action', () => {\r\n            const oldDatePickers: IDatePickerState[] = datePickersInitialState;\r\n            const action: IReduxAction<IAddDatePickerPayload> = {\r\n                type: DatePickerActions.add,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                    isRange: true,\r\n                    calendarId: 'calendar-321',\r\n                    color: 'magenta',\r\n                },\r\n            };\r\n\r\n            it('should return the old state with one more IDatePickerState', () => {\r\n                const newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, action);\r\n\r\n                expect(newDatePickers.length).toBe(oldDatePickers.length + 1);\r\n                expect(\r\n                    newDatePickers.filter((datePicker: IDatePickerState) => datePicker.id === action.payload.id).length\r\n                ).toBe(1);\r\n\r\n                action.payload.id = 'some-date-picker2';\r\n                const newDatePickers2 = datePickersReducer(newDatePickers, action);\r\n\r\n                expect(newDatePickers2.length).toBe(newDatePickers.length + 1);\r\n                expect(\r\n                    newDatePickers2.filter((datePicker: IDatePickerState) => datePicker.id === action.payload.id).length\r\n                ).toBe(1);\r\n            });\r\n\r\n            it('should return the old state with default lowerlimit and upperlimit state properties if initialDateRange is not passed', () => {\r\n                const datePickersState: IDatePickerState[] = datePickersReducer(undefined, action);\r\n\r\n                expect(datePickersState[0].lowerLimit as Date).toBe(datePickerInitialState.lowerLimit);\r\n                expect(datePickersState[0].inputLowerLimit as Date).toBe(datePickerInitialState.inputLowerLimit);\r\n                expect(datePickersState[0].appliedLowerLimit as Date).toBe(datePickerInitialState.appliedLowerLimit);\r\n\r\n                expect(datePickersState[0].upperLimit as Date).toBe(datePickerInitialState.upperLimit);\r\n                expect(datePickersState[0].inputUpperLimit as Date).toBe(datePickerInitialState.inputUpperLimit);\r\n                expect(datePickersState[0].appliedUpperLimit as Date).toBe(datePickerInitialState.appliedUpperLimit);\r\n            });\r\n\r\n            it('should return the old state with initialDateRange set properly in the state if passed', () => {\r\n                const testDateRange = [\r\n                    moment().toDate(),\r\n                    moment()\r\n                        .add(2, 'day')\r\n                        .toString(),\r\n                ];\r\n                const actionWithinitialDateRange = {\r\n                    ...action,\r\n                    payload: {...action.payload, initialDateRange: testDateRange},\r\n                };\r\n\r\n                const datePickersState: IDatePickerState[] = datePickersReducer(undefined, actionWithinitialDateRange);\r\n\r\n                expect(datePickersState[0].lowerLimit as Date).toBe(testDateRange[0] as Date);\r\n                expect(datePickersState[0].inputLowerLimit as Date).toBe(testDateRange[0] as Date);\r\n                expect(datePickersState[0].appliedLowerLimit as Date).toBe(testDateRange[0] as Date);\r\n\r\n                expect(datePickersState[0].upperLimit as Date).toBe(testDateRange[1] as Date);\r\n                expect(datePickersState[0].inputUpperLimit as Date).toBe(testDateRange[1] as Date);\r\n                expect(datePickersState[0].appliedUpperLimit as Date).toBe(testDateRange[1] as Date);\r\n            });\r\n        });\r\n\r\n        it('should return the old state without the IDatePickerState when the action is \"REMOVE_DATE_PICKER', () => {\r\n            let oldDatePickers: IDatePickerState[] = [\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2'}),\r\n                _.extend({}, BASE_DATE_PICKER_STATE),\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker3'}),\r\n            ];\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.remove,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                },\r\n            };\r\n            let newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, action);\r\n\r\n            expect(newDatePickers.length).toBe(oldDatePickers.length - 1);\r\n            expect(\r\n                newDatePickers.filter((datePicker: IDatePickerState) => datePicker.id === action.payload.id).length\r\n            ).toBe(0);\r\n\r\n            oldDatePickers = newDatePickers;\r\n            action.payload.id = 'some-date-picker2';\r\n            newDatePickers = datePickersReducer(oldDatePickers, action);\r\n\r\n            expect(newDatePickers.length).toBe(oldDatePickers.length - 1);\r\n            expect(\r\n                newDatePickers.filter((datePicker: IDatePickerState) => datePicker.id === action.payload.id).length\r\n            ).toBe(0);\r\n        });\r\n\r\n        it('should return the old state when the action is \"REMOVE_DATE_PICKER\" and the options cycle id does not exist', () => {\r\n            const oldDatePickers: IDatePickerState[] = [\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2'}),\r\n                _.extend({}, BASE_DATE_PICKER_STATE),\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker3'}),\r\n            ];\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.remove,\r\n                payload: {\r\n                    id: 'some-date-picker4',\r\n                },\r\n            };\r\n            const newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, action);\r\n\r\n            expect(newDatePickers.length).toBe(oldDatePickers.length);\r\n            expect(\r\n                newDatePickers.filter((datePicker: IDatePickerState) => datePicker.id === action.payload.id).length\r\n            ).toBe(0);\r\n        });\r\n\r\n        it('should reset all date pickers starting with the action id if the action is \"RESET_DATE_PICKERS\"', () => {\r\n            const oldDatePickers: IDatePickerState[] = [\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2'}),\r\n                _.extend({}, BASE_DATE_PICKER_STATE),\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'other-id'}),\r\n            ];\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.reset,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                },\r\n            };\r\n            const newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, action);\r\n\r\n            const datePicker: IDatePickerState = _.findWhere(newDatePickers, {id: 'some-date-picker'});\r\n            expect(datePicker.lowerLimit).toBe(datePicker.appliedLowerLimit);\r\n            expect(datePicker.upperLimit).toBe(datePicker.appliedUpperLimit);\r\n\r\n            const datePicker2: IDatePickerState = _.findWhere(newDatePickers, {id: 'some-date-picker2'});\r\n            expect(datePicker2.lowerLimit).toBe(datePicker2.appliedLowerLimit);\r\n            expect(datePicker2.upperLimit).toBe(datePicker2.appliedUpperLimit);\r\n\r\n            const otherDatePicker: IDatePickerState = _.findWhere(newDatePickers, {id: 'other-id'});\r\n            expect(otherDatePicker.lowerLimit).not.toBe(otherDatePicker.appliedLowerLimit);\r\n            expect(otherDatePicker.upperLimit).not.toBe(otherDatePicker.appliedUpperLimit);\r\n        });\r\n\r\n        it('should apply all date pickers starting with the action id if the action is \"APPLY_DATE\"', () => {\r\n            const oldDatePickers: IDatePickerState[] = [\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2'}),\r\n                _.extend({}, BASE_DATE_PICKER_STATE),\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'other-id'}),\r\n            ];\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.reset,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                },\r\n            };\r\n            const newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, action);\r\n\r\n            const datePicker: IDatePickerState = _.findWhere(newDatePickers, {id: 'some-date-picker'});\r\n            expect(datePicker.appliedLowerLimit).toBe(datePicker.lowerLimit);\r\n            expect(datePicker.appliedUpperLimit).toBe(datePicker.upperLimit);\r\n\r\n            const datePicker2: IDatePickerState = _.findWhere(newDatePickers, {id: 'some-date-picker2'});\r\n            expect(datePicker2.appliedLowerLimit).toBe(datePicker2.lowerLimit);\r\n            expect(datePicker2.appliedUpperLimit).toBe(datePicker2.upperLimit);\r\n\r\n            const otherDatePicker: IDatePickerState = _.findWhere(newDatePickers, {id: 'other-id'});\r\n            expect(otherDatePicker.appliedLowerLimit).not.toBe(otherDatePicker.lowerLimit);\r\n            expect(otherDatePicker.appliedUpperLimit).not.toBe(otherDatePicker.upperLimit);\r\n        });\r\n\r\n        it('should clear all clearable date pickers starting with the action id if the action is \"CLEAR_SELECTION\"', () => {\r\n            const oldDatePickers: IDatePickerState[] = [\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2', isClearable: true}),\r\n                _.extend({}, BASE_DATE_PICKER_STATE),\r\n                _.extend({}, BASE_DATE_PICKER_STATE, {id: 'other-id'}),\r\n            ];\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.clear,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                },\r\n            };\r\n            const newDatePickers: IDatePickerState[] = datePickersReducer(oldDatePickers, action);\r\n\r\n            const datePicker: IDatePickerState = _.findWhere(newDatePickers, {id: 'some-date-picker'});\r\n            expect(datePicker).toBe(_.findWhere(oldDatePickers, {id: 'some-date-picker'}));\r\n\r\n            const datePicker2: IDatePickerState = _.findWhere(newDatePickers, {id: 'some-date-picker2'});\r\n            expect(datePicker2.selected).toBe(DateLimits.lower);\r\n            expect(datePicker2.lowerLimit).toBeNull();\r\n            expect(datePicker2.upperLimit).toBeNull();\r\n            expect(datePicker2.inputLowerLimit).toBeNull();\r\n            expect(datePicker2.inputUpperLimit).toBeNull();\r\n\r\n            const otherDatePicker: IDatePickerState = _.findWhere(newDatePickers, {id: 'other-id'});\r\n            expect(otherDatePicker).toBe(_.findWhere(oldDatePickers, {id: 'other-id'}));\r\n        });\r\n\r\n        it(\r\n            'should return the state with the new lower limit for the date picker with the action id when the action is ' +\r\n                '\"CHANGE_LOWER_LIMIT\"',\r\n            () => {\r\n                const oldDatePickers: IDatePickerState[] = [\r\n                    _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2'}),\r\n                    _.extend({}, BASE_DATE_PICKER_STATE),\r\n                    _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker3'}),\r\n                ];\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeLowerLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        date: new Date(new Date().setHours(4, 4, 4, 4)),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = _.findWhere(datePickersReducer(oldDatePickers, action), {\r\n                    id: action.payload.id,\r\n                });\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(action.payload.date);\r\n                expect(newDatePicker.selected).toBe('');\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the state with the new upper limit and selected to empty for the date picker with the action id when the action is ' +\r\n                '\"CHANGE_UPPER_LIMIT\"',\r\n            () => {\r\n                const oldDatePickers: IDatePickerState[] = [\r\n                    _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker2'}),\r\n                    _.extend({}, BASE_DATE_PICKER_STATE),\r\n                    _.extend({}, BASE_DATE_PICKER_STATE, {id: 'some-date-picker3'}),\r\n                ];\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeUpperLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        date: new Date(new Date().setHours(4, 4, 4, 4)),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = _.findWhere(datePickersReducer(oldDatePickers, action), {\r\n                    id: action.payload.id,\r\n                });\r\n                expect(newDatePicker.upperLimit).toBe(action.payload.date);\r\n                expect(newDatePicker.selected).toBe('');\r\n            }\r\n        );\r\n\r\n        it('should not change the original state', () => {\r\n            const expectedState = datePickersInitialState.slice(0);\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.add,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                },\r\n            };\r\n            datePickersReducer(datePickersInitialState, action);\r\n\r\n            expect(expectedState).toEqual(datePickersInitialState);\r\n        });\r\n    });\r\n\r\n    describe('datePickerReducer', () => {\r\n        it('should return the default state if the action is not defined and the state is undefined', () => {\r\n            const datePickerState: IDatePickerState = datePickerReducer(undefined, GENERIC_ACTION);\r\n\r\n            expect(datePickerState).toBe(datePickerInitialState);\r\n        });\r\n\r\n        it('should return the old state when the action is not defined', () => {\r\n            const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, GENERIC_ACTION);\r\n\r\n            expect(newDatePicker).toBe(oldDatePicker);\r\n        });\r\n\r\n        it('should return a new date picker with the specified id when the action is \"ADD_DATE_PICKER\"', () => {\r\n            const oldDatePicker: IDatePickerState = datePickerInitialState;\r\n            const action: IReduxAction<IAddDatePickerPayload> = {\r\n                type: DatePickerActions.add,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                    isRange: true,\r\n                    color: 'rainbow',\r\n                    calendarId: 'radnelac',\r\n                },\r\n            };\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n            expect(newDatePicker.id).toBe(action.payload.id);\r\n            expect(newDatePicker.isRange).toBe(action.payload.isRange);\r\n            expect(newDatePicker.color).toBe(action.payload.color);\r\n            expect(newDatePicker.calendarId).toBe(action.payload.calendarId);\r\n        });\r\n\r\n        it(\r\n            'should return a new datepicker state that is unselected when the actions is \"ADD_DATE_PICKER\" ' +\r\n                'and the payload contains initiallyUnselected true',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = datePickerInitialState;\r\n                const action: IReduxAction<IAddDatePickerPayload> = {\r\n                    type: DatePickerActions.add,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        isRange: true,\r\n                        calendarId: 'calendar-321',\r\n                        color: 'green',\r\n                        initiallyUnselected: true,\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBeNull();\r\n                expect(newDatePicker.upperLimit).toBeNull();\r\n                expect(newDatePicker.appliedLowerLimit).toBeNull();\r\n                expect(newDatePicker.appliedUpperLimit).toBeNull();\r\n                expect(newDatePicker.inputLowerLimit).toBeNull();\r\n                expect(newDatePicker.inputUpperLimit).toBeNull();\r\n            }\r\n        );\r\n\r\n        it('should return a new date picker with the rangeLimit when the action is \"ADD_DATE_PICKER\"', () => {\r\n            const oldDatePicker: IDatePickerState = datePickerInitialState;\r\n            const rangeLimit: IRangeLimit = {\r\n                weeks: 1,\r\n                days: 1,\r\n                hours: 1,\r\n                message: 'test',\r\n            };\r\n            const action: IReduxAction<IAddDatePickerPayload> = {\r\n                type: DatePickerActions.add,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                    isRange: true,\r\n                    rangeLimit,\r\n                    color: 'rainbow',\r\n                    calendarId: 'radnelac',\r\n                },\r\n            };\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n            expect(newDatePicker.rangeLimit).toBe(rangeLimit);\r\n        });\r\n\r\n        it(\r\n            'should return the original state if the action is \"CHANGE_LOWER_LIMIT\" and the id is not the one specified ' +\r\n                'in the action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeLowerLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker5',\r\n                        date: new Date(new Date().setHours(3, 3, 3, 3)),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(oldDatePicker.lowerLimit);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the original state if the action is \"CHANGE_UPPER_LIMIT\" and the id is not the one specified ' +\r\n                'in the action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeUpperLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker5',\r\n                        date: new Date(new Date().setHours(3, 3, 3, 3)),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.upperLimit).toBe(oldDatePicker.upperLimit);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the date picker with the new lower limit if the action is \"CHANGE_LOWER_LIMIT\" and the id is ' +\r\n                'the one specified',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeLowerLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        date: new Date(new Date().setHours(3, 3, 3, 3)),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(action.payload.date);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the state with the upper limit selected when the datepicker state isRange ' +\r\n                'and the action is \"CHANGE_LOWER_LIMIT\"',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    id: 'some-date-picker',\r\n                    isRange: true,\r\n                });\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeLowerLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        date: new Date(),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.selected).toBe(DateLimits.upper);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the state with a null upper limit when the datepicker state isRange, ' +\r\n                'the action is \"CHANGE_LOWER_LIMIT\" and the new lower limit is after the current upper limit',\r\n            () => {\r\n                const newLowerLimit: Date = moment()\r\n                    .add(2, 'day')\r\n                    .toDate();\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    id: 'some-date-picker',\r\n                    isRange: true,\r\n                    lowerLimit: new Date(),\r\n                    inputLowerLimit: new Date(),\r\n                    upperLimit: moment()\r\n                        .add(1, 'day')\r\n                        .toDate(),\r\n                    inputUpperLimit: moment()\r\n                        .add(1, 'day')\r\n                        .toDate(),\r\n                });\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeLowerLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        date: newLowerLimit,\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(newLowerLimit);\r\n                expect(newDatePicker.inputLowerLimit).toBe(newLowerLimit);\r\n                expect(newDatePicker.upperLimit).toBeNull();\r\n                expect(newDatePicker.inputUpperLimit).toBeNull();\r\n                expect(newDatePicker.selected).toBe(DateLimits.upper);\r\n            }\r\n        );\r\n\r\n        it('should return the state with the lower limit selected when the date picker is simple and the action is \"CHANGE_LOWER_LIMIT\"', () => {\r\n            const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                id: 'some-date-picker',\r\n                simple: true,\r\n            });\r\n            const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                type: DatePickerActions.changeLowerLimit,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                    date: new Date(),\r\n                },\r\n            };\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n            expect(newDatePicker.selected).toBe(DateLimits.lower);\r\n        });\r\n\r\n        it(\r\n            'should return the date picker with the new lower limit if the action is \"CHANGE_UPPER_LIMIT\" and the id is ' +\r\n                'the one specified',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                    type: DatePickerActions.changeUpperLimit,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        date: new Date(new Date().setHours(3, 3, 3, 3)),\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.upperLimit).toBe(action.payload.date);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the date picker as is if the action is \"RESET_DATE_PICKERS\" and the id does not start with the ' +\r\n                'one from the action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.reset,\r\n                    payload: {\r\n                        id: 'date-picker',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(oldDatePicker.lowerLimit);\r\n                expect(newDatePicker.upperLimit).toBe(oldDatePicker.upperLimit);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the date picker with the limits replaced by the applied ones if the action is ' +\r\n                '\"RESET_DATE_PICKERS\" and the id starts with the one from the action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.reset,\r\n                    payload: {\r\n                        id: 'some-date',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(oldDatePicker.appliedLowerLimit);\r\n                expect(newDatePicker.lowerLimit).not.toBe(oldDatePicker.lowerLimit);\r\n                expect(newDatePicker.upperLimit).toBe(oldDatePicker.appliedUpperLimit);\r\n                expect(newDatePicker.upperLimit).not.toBe(oldDatePicker.upperLimit);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the date picker as is if the action is \"APPLY_DATE\" and the id does not start with the one ' +\r\n                'from the action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.apply,\r\n                    payload: {\r\n                        id: 'date-picker',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.appliedLowerLimit);\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.appliedUpperLimit);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the date picker with the applied limits replaced by the current ones value if the action is ' +\r\n                '\"APPLY_DATE\" and the id starts with the one from the action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.apply,\r\n                    payload: {\r\n                        id: 'some-date',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedLowerLimit).not.toBe(oldDatePicker.appliedLowerLimit);\r\n                expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.lowerLimit);\r\n                expect(newDatePicker.appliedUpperLimit).not.toBe(oldDatePicker.appliedUpperLimit);\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.upperLimit);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should apply the lower limit to the upper limit if the upper limit it lower than the lower when the action ' +\r\n                'is \"APPLY_DATE\"',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    upperLimit: new Date(new Date().setHours(0, 0, 1, 1)),\r\n                });\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.apply,\r\n                    payload: {\r\n                        id: 'some-date',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedLowerLimit).not.toBe(oldDatePicker.appliedLowerLimit);\r\n                expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.lowerLimit);\r\n                expect(newDatePicker.appliedUpperLimit).not.toBe(oldDatePicker.appliedUpperLimit);\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.lowerLimit);\r\n            }\r\n        );\r\n\r\n        it('should apply the input limit if the new limits are not valid', () => {\r\n            const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                upperLimit: undefined,\r\n                lowerLimit: undefined,\r\n                inputUpperLimit: new Date(new Date().setHours(2, 0, 1, 1)),\r\n                inputLowerLimit: new Date(new Date().setHours(0, 0, 1, 1)),\r\n            });\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.apply,\r\n                payload: {\r\n                    id: 'some-date',\r\n                },\r\n            };\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n            expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.inputLowerLimit);\r\n            expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.inputUpperLimit);\r\n        });\r\n\r\n        it(\r\n            'should apply the already applied limit if the new limits are not valid and neither are the input limits ' +\r\n                ' and the datepicker is not clearable',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    upperLimit: undefined,\r\n                    lowerLimit: undefined,\r\n                    inputUpperLimit: undefined,\r\n                    inputLowerLimit: undefined,\r\n                    appliedUpperLimit: new Date(new Date().setHours(2, 0, 1, 1)),\r\n                    appliedLowerLimit: new Date(new Date().setHours(0, 0, 1, 1)),\r\n                });\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.apply,\r\n                    payload: {\r\n                        id: 'some-date',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.appliedLowerLimit);\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.appliedUpperLimit);\r\n            }\r\n        );\r\n\r\n        it('should allows to apply null limits when the datepicker is clearable', () => {\r\n            const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                isClearable: true,\r\n                upperLimit: null,\r\n                lowerLimit: null,\r\n                appliedUpperLimit: new Date(new Date().setHours(2, 0, 1, 1)),\r\n                appliedLowerLimit: new Date(new Date().setHours(0, 0, 1, 1)),\r\n            });\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.apply,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                },\r\n            };\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n            expect(newDatePicker.appliedLowerLimit).toBeNull();\r\n            expect(newDatePicker.appliedUpperLimit).toBeNull();\r\n        });\r\n\r\n        it(\r\n            'should return the original state if the action is \"SELECT_DATE\" and the id is not the one specified in the' +\r\n                'action',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<ISelectDatePickerPayload> = {\r\n                    type: DatePickerActions.select,\r\n                    payload: {\r\n                        id: 'some-date-picker5',\r\n                        limit: DateLimits.upper,\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.selected).toBe(oldDatePicker.selected);\r\n                expect(newDatePicker.upperLimit).toBeDefined();\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the date picker with the new selected limit and the limit date unchanged if the action is' +\r\n                '\"SELECT_DATE\" and the id is the one specified',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                const action: IReduxAction<ISelectDatePickerPayload> = {\r\n                    type: DatePickerActions.select,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                        limit: DateLimits.upper,\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.selected).toBe(action.payload.limit);\r\n                expect(newDatePicker.upperLimit).toBe(oldDatePicker.upperLimit);\r\n            }\r\n        );\r\n\r\n        it('should set the limits to null and select the lower limit when the action is \"CLEAR_SELECTION', () => {\r\n            const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                isClearable: true,\r\n            });\r\n            const action: IReduxAction<IDatePickerPayload> = {\r\n                type: DatePickerActions.clear,\r\n                payload: {\r\n                    id: 'some-date',\r\n                },\r\n            };\r\n            const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n            expect(newDatePicker.selected).toBe(DateLimits.lower);\r\n            expect(newDatePicker.lowerLimit).toBeNull();\r\n            expect(newDatePicker.upperLimit).toBeNull();\r\n            expect(newDatePicker.inputLowerLimit).toBeNull();\r\n            expect(newDatePicker.inputUpperLimit).toBeNull();\r\n        });\r\n\r\n        it(\r\n            'should return the oldState when the action is \"CLEAR_SELECTION and the datepicker id does not contain ' +\r\n                'the payload id',\r\n            () => {\r\n                const oldDatePicker: IDatePickerState = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    isClearable: true,\r\n                });\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.clear,\r\n                    payload: {\r\n                        id: 'some-other-date-picker',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker).toBe(oldDatePicker);\r\n            }\r\n        );\r\n\r\n        it(\r\n            'should return the oldState when the action is \"CLEAR_SELECTION and the datepicker ' + 'is not clearable',\r\n            () => {\r\n                const action: IReduxAction<IDatePickerPayload> = {\r\n                    type: DatePickerActions.clear,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                    },\r\n                };\r\n                const newDatePicker: IDatePickerState = datePickerReducer(BASE_DATE_PICKER_STATE, action);\r\n\r\n                expect(newDatePicker).toBe(BASE_DATE_PICKER_STATE);\r\n            }\r\n        );\r\n\r\n        it('should not change the original state', () => {\r\n            const expectedState = _.extend({}, datePickerInitialState);\r\n            const action: IReduxAction<IChangeDatePickerPayload> = {\r\n                type: DatePickerActions.changeUpperLimit,\r\n                payload: {\r\n                    id: 'some-date-picker',\r\n                    date: new Date(new Date().setHours(3, 3, 3, 3)),\r\n                },\r\n            };\r\n            datePickerReducer(datePickerInitialState, action);\r\n\r\n            expect(expectedState).toEqual(datePickerInitialState);\r\n        });\r\n\r\n        describe('reducer for the action \"APPLY_DATE\"', () => {\r\n            let action: IReduxAction<IDatePickerPayload>;\r\n            let oldDatePicker: IDatePickerState;\r\n            let newDatePicker: IDatePickerState;\r\n\r\n            beforeEach(() => {\r\n                action = {\r\n                    type: DatePickerActions.apply,\r\n                    payload: {\r\n                        id: 'some-date-picker',\r\n                    },\r\n                };\r\n            });\r\n\r\n            it('should return the inputLowerLimit if the lowerLimit is not defined and the datepicker is not clearable', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    lowerLimit: undefined,\r\n                });\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.inputLowerLimit);\r\n            });\r\n\r\n            it('should return the appliedLowerLimit if the lowerLimit and inputLowerLimits are not defined', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    lowerLimit: undefined,\r\n                    inputLowerLimit: undefined,\r\n                });\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedLowerLimit).toBe(oldDatePicker.appliedLowerLimit);\r\n            });\r\n\r\n            it('should return the lowerLimit if the lowerLimit is defined', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.lowerLimit).toBe(oldDatePicker.lowerLimit);\r\n            });\r\n\r\n            it('should return the inputUpperLimit if the upperLimit is not defined', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    upperLimit: undefined,\r\n                });\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.inputUpperLimit);\r\n            });\r\n\r\n            it('should return the appliedUpperLimit if the upperLimit and inputUpperLimit are not defined', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    upperLimit: undefined,\r\n                    inputUpperLimit: undefined,\r\n                });\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.appliedUpperLimit);\r\n            });\r\n\r\n            it('should return the upperLimit if its greater than the lowerLimit', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE);\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.upperLimit);\r\n            });\r\n\r\n            it('should return the lowerLimit if the upperLimit is smaller than the lowerLimit', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    lowerLimit: new Date().setHours(2, 1, 2, 1),\r\n                    upperLimit: new Date().setHours(1, 1, 2, 1),\r\n                });\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.lowerLimit);\r\n            });\r\n\r\n            it('should return the lowerLimit if the upperLimit is equal than the lowerLimit', () => {\r\n                oldDatePicker = _.extend({}, BASE_DATE_PICKER_STATE, {\r\n                    lowerLimit: new Date().setHours(1, 1, 2, 1),\r\n                    upperLimit: new Date().setHours(1, 1, 2, 1),\r\n                });\r\n                newDatePicker = datePickerReducer(oldDatePicker, action);\r\n\r\n                expect(newDatePicker.appliedUpperLimit).toBe(oldDatePicker.lowerLimit);\r\n            });\r\n        });\r\n    });\r\n});\r\n"}}]);
//# sourceMappingURL=299.bundle.js.map