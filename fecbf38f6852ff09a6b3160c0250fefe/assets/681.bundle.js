(window.webpackJsonp=window.webpackJsonp||[]).push([[681],{1770:function(e,t,r){"use strict";r.r(t),t.default="import {mount, ReactWrapper, ShallowWrapper} from 'enzyme';\r\nimport {shallowWithStore} from 'enzyme-redux';\r\nimport * as React from 'react';\r\nimport {act} from 'react-dom/test-utils';\r\nimport {Provider} from 'react-redux';\r\nimport {Store} from 'redux';\r\nimport * as _ from 'underscore';\r\n\r\nimport {withServerSideProcessing} from '../../../../hoc/withServerSideProcessing/withServerSideProcessing';\r\nimport {IReactVaporState} from '../../../../ReactVapor';\r\nimport {clearState} from '../../../../utils/ReduxUtils';\r\nimport {TestUtils} from '../../../../utils/tests/TestUtils';\r\nimport {UUID} from '../../../../utils/UUID';\r\nimport {DraggableSelectedOption} from '../../../dropdownSearch/MultiSelectDropdownSearch/DraggableSelectedOption';\r\nimport {selectFlatSelect} from '../../../flatSelect/FlatSelectActions';\r\nimport {IFlatSelectOptionProps} from '../../../flatSelect/FlatSelectOption';\r\nimport {IItemBoxProps} from '../../../itemBox/ItemBox';\r\nimport {reorderListBoxOption, unselectListBoxOption} from '../../../listBox/ListBoxActions';\r\nimport {IMultiSelectOwnProps, IMultiSelectProps, MultiSelectConnected} from '../../MultiSelectConnected';\r\nimport {toggleSelect} from '../../SelectActions';\r\nimport {SelectConnected} from '../../SelectConnected';\r\nimport {MultiSelectWithPredicate} from '../SelectComponents';\r\nimport {ISelectWithPredicateProps, selectWithPredicate} from '../SelectWithPredicate';\r\n\r\ndescribe('Select', () => {\r\n    describe('<MultiSelectWithPredicate />', () => {\r\n        let wrapper: ReactWrapper<any, any>;\r\n        let multiSelect: ReactWrapper<IMultiSelectProps, void>;\r\n        let store: Store<IReactVaporState>;\r\n\r\n        const id: string = 'multi-select-with-predicate';\r\n        const defaultFlatSelectOptions: IFlatSelectOptionProps[] = [\r\n            {id: UUID.generate(), option: {content: 'All'}, selected: true},\r\n            {id: UUID.generate(), option: {content: 'None'}},\r\n        ];\r\n        const matchPredicate = (predicate: string, item: IItemBoxProps) => {\r\n            return predicate === defaultFlatSelectOptions[0].id;\r\n        };\r\n\r\n        const basicProps: ISelectWithPredicateProps & IMultiSelectOwnProps = {\r\n            id,\r\n            items: [],\r\n            options: defaultFlatSelectOptions,\r\n            matchPredicate,\r\n        };\r\n\r\n        const mountMultiSelect = (props?: Partial<ISelectWithPredicateProps & IMultiSelectOwnProps>) => {\r\n            wrapper = mount(\r\n                <Provider store={store}>\r\n                    <MultiSelectWithPredicate {...basicProps} {...props} />\r\n                </Provider>,\r\n                {attachTo: document.getElementById('App')}\r\n            );\r\n            multiSelect = wrapper.find(SelectConnected).first();\r\n        };\r\n\r\n        beforeEach(() => {\r\n            store = TestUtils.buildStore();\r\n        });\r\n\r\n        afterEach(() => {\r\n            store.dispatch(clearState());\r\n            if (wrapper && wrapper.exists()) {\r\n                wrapper.detach();\r\n            }\r\n        });\r\n\r\n        describe('mount and unmount', () => {\r\n            it('should not throw on mount', () => {\r\n                expect(() => mountMultiSelect()).not.toThrow();\r\n            });\r\n\r\n            it('should not throw on unmount', () => {\r\n                mountMultiSelect();\r\n                expect(() => wrapper.unmount()).not.toThrow();\r\n            });\r\n\r\n            it('should add the list box to the state when mounted', () => {\r\n                expect(store.getState().selects.length).toBe(0);\r\n\r\n                mountMultiSelect();\r\n\r\n                expect(store.getState().selects.length).toBe(1);\r\n            });\r\n\r\n            it('should remove the list box from the state when the component unmount', () => {\r\n                mountMultiSelect();\r\n\r\n                expect(store.getState().selects.length).toBe(1);\r\n                wrapper.unmount();\r\n\r\n                expect(store.getState().selects.length).toBe(0);\r\n            });\r\n        });\r\n\r\n        it('should hide items when they do not match the predicates', () => {\r\n            const items = [{value: 'a'}, {value: 'b', selected: true}, {value: 'c', selected: true}];\r\n\r\n            mountMultiSelect({items});\r\n            store.dispatch(toggleSelect(id, true));\r\n            store.dispatch(selectFlatSelect(id, defaultFlatSelectOptions[1].id));\r\n            wrapper.update();\r\n            multiSelect = wrapper.find(SelectConnected);\r\n\r\n            expect(multiSelect.props().items.length).toBe(items.length);\r\n            multiSelect\r\n                .find(SelectConnected)\r\n                .props()\r\n                .items.every((item: IItemBoxProps) => expect(item.hidden).toBe(true));\r\n        });\r\n\r\n        it('should not show items that are already hidden', () => {\r\n            const items = [\r\n                {value: 'a', hidden: true},\r\n                {value: 'b', selected: true},\r\n                {value: 'c', selected: true},\r\n            ];\r\n\r\n            mountMultiSelect({items});\r\n            store.dispatch(toggleSelect(id, true));\r\n            store.dispatch(selectFlatSelect(id, defaultFlatSelectOptions[0].id));\r\n            wrapper.update();\r\n            multiSelect = wrapper.find(SelectConnected);\r\n\r\n            expect(multiSelect.props().items.length).toBe(items.length);\r\n            expect(multiSelect.find(SelectConnected).props().items[0].hidden).toBe(true);\r\n            expect(multiSelect.find(SelectConnected).props().items[1].hidden).toBeUndefined();\r\n            expect(multiSelect.find(SelectConnected).props().items[2].hidden).toBeUndefined();\r\n        });\r\n\r\n        describe('Sortable', () => {\r\n            it('should be possible to reorder items', () => {\r\n                const spy = spyOn(store, 'dispatch').and.callThrough();\r\n                const items = [\r\n                    {value: 'a', hidden: true},\r\n                    {value: 'b', selected: true},\r\n                    {value: 'c', selected: true},\r\n                ];\r\n\r\n                mountMultiSelect({items, sortable: true});\r\n\r\n                // Move b from 0 to 1\r\n                multiSelect\r\n                    .find(DraggableSelectedOption)\r\n                    .first()\r\n                    .prop('move')(0, 1);\r\n                expect(spy).toHaveBeenCalledWith(reorderListBoxOption(id, [items[2].value, items[1].value]));\r\n            });\r\n\r\n            it('should be possible to delete an item', () => {\r\n                const spy = spyOn(store, 'dispatch').and.callThrough();\r\n                const items = [\r\n                    {value: 'a', hidden: true},\r\n                    {value: 'b', selected: true},\r\n                    {value: 'c', selected: true},\r\n                ];\r\n\r\n                mountMultiSelect({items, sortable: true});\r\n\r\n                // Move b from 0 to 1\r\n                multiSelect\r\n                    .find(DraggableSelectedOption)\r\n                    .first()\r\n                    .prop('onRemoveClick')();\r\n                expect(spy).toHaveBeenCalledWith(unselectListBoxOption(id, items[1].value));\r\n            });\r\n        });\r\n\r\n        describe('when predicates are processed on the server side', () => {\r\n            const ServerSideMultiSelectWithPredicates = _.compose(\r\n                withServerSideProcessing,\r\n                selectWithPredicate\r\n            )(MultiSelectConnected);\r\n\r\n            const items = [\r\n                {value: 'a', hidden: true},\r\n                {value: 'b', selected: true},\r\n                {value: 'c', selected: true},\r\n            ];\r\n\r\n            it('should not filter the items based on any predicate because it is done on the server', () => {\r\n                const component: ShallowWrapper<ISelectWithPredicateProps> = shallowWithStore(\r\n                    <ServerSideMultiSelectWithPredicates\r\n                        {...basicProps}\r\n                        items={items}\r\n                        predicate={basicProps.options[1].id}\r\n                    />,\r\n                    store\r\n                )\r\n                    .dive()\r\n                    .dive();\r\n                expect(component.props().items).toEqual(items);\r\n            });\r\n\r\n            it('should trigger the onUpdate prop when the selected predicate changes', () => {\r\n                const onUpdateSpy = jasmine.createSpy('onUpdate');\r\n\r\n                wrapper = mount(\r\n                    <Provider store={store}>\r\n                        <ServerSideMultiSelectWithPredicates {...basicProps} onUpdate={onUpdateSpy} />\r\n                    </Provider>,\r\n                    {attachTo: document.getElementById('App')}\r\n                );\r\n\r\n                expect(onUpdateSpy).toHaveBeenCalledTimes(1);\r\n\r\n                store.dispatch(toggleSelect(id, true));\r\n                act(() => {\r\n                    store.dispatch(selectFlatSelect(id, defaultFlatSelectOptions[1].id));\r\n                });\r\n\r\n                expect(onUpdateSpy).toHaveBeenCalledTimes(2);\r\n            });\r\n        });\r\n    });\r\n});\r\n"}}]);
//# sourceMappingURL=681.bundle.js.map